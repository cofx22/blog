<!DOCTYPE html>
<html lang="en">
  <head>
    <title>BBC: blog by cofx</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy"
      content="default-src 'self';
        media-src 'self' https://ljpengelen.github.io/groovid19/;
        script-src 'self' https://livejs.com https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/;
        style-src 'self' https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/
          'sha256-iRtqXVmOMp/hyF5UngK6PellD3q+F7toTW0WZBpaIyk='
          'sha256-47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU';
        object-src 'none';
        base-uri 'none'"/>
    <link type="application/atom+xml" rel="alternate" href="atom.xml" title="BBC: blog by cofx">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/plugins/autoloader/prism-autoloader.min.js"></script>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/themes/prism.min.css">
    <link rel="stylesheet" href="style.css">

    

    <meta name="title" content="BBC: blog by cofx">
    <meta name="twitter:title" content="BBC: blog by cofx">
    <meta property="og:title" content="BBC: blog by cofx">
    <meta property="og:type" content="website">
    
      <meta name="description" content="A blog about blogging quickly">
      <meta name="twitter:description" content="A blog about blogging quickly">
      <meta property="og:description" content="A blog about blogging quickly">
    
    
      <meta name="twitter:url" content="https://blog.cofx.nl/index.html">
      <meta property="og:url" content="https://blog.cofx.nl/index.html">
    
    
      <meta name="twitter:card" content="summary">
    
    
    
  </head>
  <body>
    <div class="header">
      <h1 class="site-title">
        <a class="page-link" href="index.html">BBC: blog by cofx</a>
      </h1>
      <div class="site-nav">
        <a class="page-link" href="archive.html">Archive</a>
        <a class="page-link" href="tags/index.html">Tags</a>
        <a class="page-link" href="atom.xml">Feed</a>
      </div>
    </div>
    <div class="wrapper">
      <div>
<h1>
  
  <a href="browser-beats-snare-and-hi-hat.html">
  
  Browser beats II: synthesizing a snare drum and a hi-hat
  
  </a>
  
</h1>
<p><em>This post first appeared on <a href='https://www.kabisa.nl/tech/'>Kabisa's Tech Blog</a>.</em></p><p>In the previous installment of browser beats, we used the <a href='https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API'>Web Audio API</a> to synthesize a kick drum. This time, we’ll look at snares and hi-hats. Once you know how to synthesize kicks, snares and hi-hats are not far away.</p><h2>Snare</h2><p>The snare sound we’ll synthesize consists of two components. One component represents the vibrating skins of the snare drum, the other represents the vibrating snares. For the first component, we’ll use two sine-like waves, one at 185Hz and the other at 349Hz. I took these values from a <a href='https://www.musictech.net/tutorials/modular-eurorack-snare-tutorial/'>MusicTech tutorial</a>. An article in <a href='https://www.soundonsound.com/techniques/practical-snare-drum-synthesis'>Sound on Sound</a> mentions 180Hz and 330Hz. Obviously, you should go with whatever frequencies sound best to you.</p><pre><code class="lang-JavaScript">const playSnare = &#40;&#41; =&gt; {
    const lowTriangle = audioContext.createOscillator&#40;&#41;;
    lowTriangle.type = 'triangle';
    lowTriangle.frequency.value = 185;

    const highTriangle = audioContext.createOscillator&#40;&#41;;
    highTriangle.type = 'triangle';
    highTriangle.frequency.value = 349;

    const lowWaveShaper = audioContext.createWaveShaper&#40;&#41;;
    lowWaveShaper.curve = distortionCurve&#40;5&#41;;

    const highWaveShaper = audioContext.createWaveShaper&#40;&#41;;
    highWaveShaper.curve = distortionCurve&#40;5&#41;;

    const lowTriangleGainNode = audioContext.createGain&#40;&#41;;
    lowTriangleGainNode.gain.value = 1;
    lowTriangleGainNode.gain.linearRampToValueAtTime&#40;0, audioContext.currentTime + 0.1&#41;

    const highTriangleGainNode = audioContext.createGain&#40;&#41;;
    highTriangleGainNode.gain.value = 1;
    highTriangleGainNode.gain.linearRampToValueAtTime&#40;0, audioContext.currentTime + 0.1&#41;

    const snareGainNode = audioContext.createGain&#40;&#41;;
    snareGainNode.gain.value = 1;

    lowTriangle.connect&#40;lowWaveShaper&#41;;
    lowWaveShaper.connect&#40;lowTriangleGainNode&#41;;
    lowTriangleGainNode.connect&#40;snareGainNode&#41;;
    snareGainNode.connect&#40;audioContext.destination&#41;;

    highTriangle.connect&#40;highWaveShaper&#41;;
    highWaveShaper.connect&#40;highTriangleGainNode&#41;;
    highTriangleGainNode.connect&#40;snareGainNode&#41;;

    lowTriangle.start&#40;audioContext.currentTime&#41;;
    lowTriangle.stop&#40;audioContext.currentTime + 1&#41;;

    highTriangle.start&#40;audioContext.currentTime&#41;;
    highTriangle.stop&#40;audioContext.currentTime + 1&#41;;
};
</code></pre><p>Together, these two sound like this:</p><p><audio controls="" src="https://ljpengelen.github.io/groovid19/snare-and-hihat/audio/sines.mp3"></audio></p><p>We could have used pure sines waves here. There’s no need for applying the trick we used for the kick drum. What you’re witnessing here is a sheer waste of processing power due to my unwillingness to refactor this code right now. Let’s just say that I like the slightly more metallic sound of the distorted traingle waves.</p><p>We’ll use white noise again to represent the second component. This time, we’ll use a filter to cut of all frequencies below 2kHz.</p><pre><code class="lang-JavaScript">const playSnare = &#40;&#41; =&gt; {

    ...

    const noise = whiteNoiseBufferSource&#40;&#41;;

    const noiseGainNode = audioContext.createGain&#40;&#41;;
    noiseGainNode.gain.value = 1;
    noiseGainNode.gain.linearRampToValueAtTime&#40;0, audioContext.currentTime + 0.2&#41;;

    const noiseFilter = audioContext.createBiquadFilter&#40;&#41;;
    noiseFilter.type = 'highpass';
    noiseFilter.frequency.value = 2000;

    noise.connect&#40;noiseGainNode&#41;;
    noiseGainNode.connect&#40;noiseFilter&#41;;
    noiseFilter.connect&#40;snareGainNode&#41;;

    noise.start&#40;audioContext.currentTime&#41;;
    noise.stop&#40;audioContext.currentTime + 1&#41;;
};
</code></pre><p>The filtered noise sounds like this:</p><p><audio controls="" src="https://ljpengelen.github.io/groovid19/snare-and-hihat/audio/snare-noise.mp3"></audio></p><p>Finally, the distorted sines and the noise together sound like this:</p><p><audio controls="" src="https://ljpengelen.github.io/groovid19/snare-and-hihat/audio/snare.mp3"></audio></p><h2>Hi-hat</h2><p>Some filtered white noise is all you need for a hi-hat. We again cut all frequencies below 2kHz. This time, the volume should fade to zero in 100 milliseconds.</p><pre><code class="lang-JavaScript">const playHiHat = &#40;&#41; =&gt; {
    const noise = whiteNoiseBufferSource&#40;&#41;;

    const noiseGainNode = audioContext.createGain&#40;&#41;;
    noiseGainNode.gain.value = 1;
    noiseGainNode.gain.setValueAtTime&#40;1, audioContext.currentTime + 0.001&#41;;
    noiseGainNode.gain.linearRampToValueAtTime&#40;0, audioContext.currentTime + 0.1&#41;;

    const noiseFilter = audioContext.createBiquadFilter&#40;&#41;;
    noiseFilter.type = 'highpass';
    noiseFilter.frequency.value = 2000;

    const hiHatGainNode = audioContext.createGain&#40;&#41;;
    hiHatGainNode.gain.value = 0.3;

    noise.connect&#40;noiseGainNode&#41;;
    noiseGainNode.connect&#40;noiseFilter&#41;;
    noiseFilter.connect&#40;hiHatGainNode&#41;;
    hiHatGainNode.connect&#40;audioContext.destination&#41;;

    hiHatGainNode.connect&#40;analyser&#41;

    noise.start&#40;audioContext.currentTime&#41;;
    noise.stop&#40;audioContext.currentTime + 1&#41;;
};
</code></pre><p>The end result sounds like this:</p><p><audio controls="" src="https://ljpengelen.github.io/groovid19/snare-and-hihat/audio/hihat-noise.mp3"></audio></p><h2>Conclusion</h2><p>The snare and hi-hat we’ve produced here are pretty basic. If you want to dig deeper to achieve prettier or more realistic results, the following articles would be good starting points:</p><ul><li><a href='https://www.soundonsound.com/techniques/practical-snare-drum-synthesis'>https://www.soundonsound.com/techniques/practical-snare-drum-synthesis</a></li><li><a href='https://www.soundonsound.com/techniques/practical-cymbal-synthesis'>https://www.soundonsound.com/techniques/practical-cymbal-synthesis</a></li></ul><p>Don’t forget to put these sounds to the test by playing along with your favorite songs: <a href='https://ljpengelen.github.io/groovid19/kick-snare-hihat.html'>https://ljpengelen.github.io/groovid19/kick-snare-hihat.html</a>.</p>

<p>
  <i>Published: 2020-05-25</i>
  
</p>

<p>
  <i>
  Tagged:
  
  <span class="tag">
    <a href="tags/Browser-beats.html">Browser beats</a>
  </span>
  
  </i>
</p>


</div>
<div>
<h1>
  
  <a href="browser-beats-kick-drum.html">
  
  Browser beats I: synthesizing a kick drum
  
  </a>
  
</h1>
<p><em>This post first appeared on <a href='https://www.kabisa.nl/tech/'>Kabisa's Tech Blog</a>.</em></p><p>Because I wanted to gain some experience in working with <a href='https://angular.io/'>Angular</a> and <a href='https://ngrx.io/'>NgRx</a>, I started building a sample-based step sequencer that runs in the browser. To do that, I had to dive into the <a href='https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API'>Web Audio API</a>. I’ll write something about that step sequencer later. First, I want to take a look at the basics of the Web Audio API and try to synthesize a kick drum.</p><h2>The basis</h2><p>At the basis of most syntesized kick drums, there’s a sine wave, or something that’s close to a sine wave. The function below produces a sine wave with a frequency of 55Hz that plays for the duration of ten seconds.</p><pre><code class="lang-JavaScript">const play = &#40;&#41; =&gt; {
    const audioContextClass = window.AudioContext || window.webkitAudioContext;
    const audioContext = new audioContextClass&#40;&#41;;

    const sine = audioContext.createOscillator&#40;&#41;;
    sine.type = 'sine';
    sine.frequency.value = 55;

    sine.start&#40;audioContext.currentTime&#41;;
    sine.stop&#40;audioContext.currentTime + 10&#41;;
}
</code></pre><p>It sounds like this: (You might not hear it over your laptop’s speakers. You’ll need decent speakers or headphones that are able to reproduce low frequencies.)</p><p><audio controls="" src="https://ljpengelen.github.io/groovid19/kick/audio/sine-55Hz.mp3"></audio></p><p>When you visualize that sound, as shown below, you’ll see why it’s called a sine wave. The left-hand side of the figure shows the waveform, and the right-hand side shows the sound spectrum.</p><p><img src="assets/browser-beats-i/sine-55Hz.png" alt="Sine at 55Hz" /></p><p>The sound spectrum is almost completely empty, except for a narrow spike at the rightmost end. This explains why you might not hear the sound over your laptop speakers, for example. Not all speakers are capable of reproducing sounds at low frequencies. You can emulate the frequency response of such speakers by applying a high-pass filter. If you filter out all frequencies below 120Hz, this is what’s left of our sine wave:</p><p><audio controls="" src="https://ljpengelen.github.io/groovid19/kick/audio/sine-55Hz-high-pass-120Hz.mp3"></audio></p><p>The graphs below further illustrate that not much is left of the original sound.</p><p><img src="assets/browser-beats-i/sine-55Hz-high-pass-120Hz.png" alt="Sine at 55Hz through a high-pass filter at 120Hz" /></p><p>What does that mean for our synthesized kick drum? We’ll apply a trick to make your ears believe that there’s still some bass to be heard, even when listening to speakers that can’t reproduce low frequencies very well. Instead of a sine wave, we’ll start out with a triangle wave.</p><pre><code class="lang-JavaScript">const play = &#40;&#41; =&gt; {
    const audioContextClass = window.AudioContext || window.webkitAudioContext;
    const audioContext = new audioContextClass&#40;&#41;;

    const triangle = audioContext.createOscillator&#40;&#41;;
    triangle.type = 'triangle';
    triangle.frequency.value = 55;

    triangle.connect&#40;audioContext.destination&#41;;

    triangle.start&#40;audioContext.currentTime&#41;;
    triangle.stop&#40;audioContext.currentTime + 10&#41;;
}
</code></pre><p>Without further processing, it will look like this:</p><p><img src="assets/browser-beats-i/triangle-55Hz.png" alt="Triangle at 55Hz" /></p><p>It’s again clear where the name comes from. It’s also clear that there’s much more going on in the spectrum graph.</p><p>Unfortunately, it sounds a little abrasive, like this:</p><p><audio controls="" src="https://ljpengelen.github.io/groovid19/kick/audio/triangle-55Hz.mp3"></audio></p><p>Ideally, we’d like to process this triangle wave in such a way that it sounds more like the sine wave, without cutting off too much of the high-frequency sounds. We can do that using a wave shaper.</p><pre><code class="lang-JavaScript">const distortionCurve = &#40;amount&#41; =&gt; {
    const numberOfSamples = 44100;
    const curve = new Float32Array&#40;numberOfSamples&#41;;
    const deg = Math.PI / 180;
    for &#40;let i = 0; i &lt; numberOfSamples; ++i&#41; {
        const x = i &#42; 2 / numberOfSamples - 1;
        curve&#91;i&#93; = &#40;3 + amount&#41; &#42; x &#42; 20 &#42; deg / &#40; Math.PI + amount &#42; Math.abs&#40;x&#41; &#41;;
    }
    return curve;
};

const play = &#40;&#41; =&gt; {
    const audioContextClass = window.AudioContext || window.webkitAudioContext;
    const audioContext = new audioContextClass&#40;&#41;;

    const triangle = audioContext.createOscillator&#40;&#41;;
    triangle.type = 'triangle';
    triangle.frequency.value = 55;

    const waveShaper = audioContext.createWaveShaper&#40;&#41;;
    waveShaper.curve = distortionCurve&#40;5&#41;;

    triangle.connect&#40;waveShaper&#41;;
    waveShaper.connect&#40;audioContext.destination&#41;;

    triangle.start&#40;audioContext.currentTime&#41;;
    triangle.stop&#40;audioContext.currentTime + 10&#41;;
}
</code></pre><p>The curve I’m using above comes from a <a href='https://stackoverflow.com/questions/22312841/waveshaper-node-in-webaudio-how-to-emulate-distortion'>Stack Overflow</a> answer by <a href='https://stackoverflow.com/users/717965/kevin-ennis'>Kevin Ennis</a>. In theory, there are multiple <a href='https://en.wikipedia.org/wiki/Sigmoid_function'>Sigmoid functions</a> that you could use. I only tried this one and stuck with it because I liked the result.</p><p>Speaking of results, here are the graphs for this sound:</p><p><img src="assets/browser-beats-i/triangle-55Hz-waveshaper.png" alt="Triangle at 55Hz through a wave shaper" /></p><p>The triangles look a lot more like sines, and there is still something going on at the higher end of the frequency spectrum. The resulting sound sounds like this:</p><p><audio controls="" src="https://ljpengelen.github.io/groovid19/kick/audio/triangle-55Hz-waveshaper.mp3"></audio></p><p>The <a href='https://webaudio.github.io/web-audio-api/#dom-waveshapernode-curve'>W3C spec</a> gives a good explanation of what’s actually going on when you apply a wave shaper with a certain curve. I won’t go into the details here.</p><p>What did we achieve with this detour? If we filter out the low frequencies again to simulate cheaper speakers, we end up with the following sound:</p><p><audio controls="" src="https://ljpengelen.github.io/groovid19/kick/audio/triangle-55Hz-waveshaper-high-pass.mp3"></audio></p><p>The graphs for this filtered sound are shown below. When you compare these to the ones for the filtered sine wave shown above, you’ll notice that there’s still something to hear after removing the low end. This is enough for you ears to trick you into believing that there’s actually some low end left, even when there isn’t.</p><p><img src="assets/browser-beats-i/triangle-waveshaper-high-pass.png" alt="Triangle at 55Hz through a wave shaper and a high-pass filter at 120Hz" /></p><h2>Make it boom</h2><p>The sound we ended up with sounds a little like “WOOOOOOOOOOH”. Let’s turn that into a “WOOOOM”.</p><pre><code class="lang-JavaScript">const play = &#40;&#41; =&gt; {
    const audioContextClass = window.AudioContext || window.webkitAudioContext;
    const audioContext = new audioContextClass&#40;&#41;;

    const triangle = audioContext.createOscillator&#40;&#41;;
    triangle.type = 'triangle';
    triangle.frequency.value = 55;

    const waveShaper = audioContext.createWaveShaper&#40;&#41;;
    waveShaper.curve = distortionCurve&#40;5&#41;;

    const triangleGainNode = audioContext.createGain&#40;&#41;;
    triangleGainNode.gain.value = 1;
    triangleGainNode.gain.linearRampToValueAtTime&#40;0, audioContext.currentTime + 0.6&#41;

    triangle.connect&#40;waveShaper&#41;;
    waveShaper.connect&#40;triangleGainNode&#41;;
    triangleGainNode.connect&#40;audioContext.destination&#41;;

    triangle.start&#40;audioContext.currentTime&#41;;
    triangle.stop&#40;audioContext.currentTime + 1&#41;;
}
</code></pre><p>In the snippet above, you’ll see that we’re using a gain node to gradually fade out over the course of 600 milliseconds. The end result sounds like this.</p><p><audio controls="" src="https://ljpengelen.github.io/groovid19/kick/audio/release.mp3"></audio></p><p>Now that we have something that sounds like “WOOOOM”, let’s make it sound like “BOOOOM”.</p><pre><code class="lang-JavaScript">const play = &#40;&#41; =&gt; {
    const audioContextClass = window.AudioContext || window.webkitAudioContext;
    const audioContext = new audioContextClass&#40;&#41;;

    const triangle = audioContext.createOscillator&#40;&#41;;
    triangle.type = 'triangle';
    triangle.frequency.value = 220;
    triangle.frequency.exponentialRampToValueAtTime&#40;55, audioContext.currentTime + 0.1&#41;;

    const waveShaper = audioContext.createWaveShaper&#40;&#41;;
    waveShaper.curve = distortionCurve&#40;5&#41;;

    const triangleGainNode = audioContext.createGain&#40;&#41;;
    triangleGainNode.gain.value = 1;
    triangleGainNode.gain.linearRampToValueAtTime&#40;0, audioContext.currentTime + 0.6&#41;

    triangle.connect&#40;waveShaper&#41;;
    waveShaper.connect&#40;triangleGainNode&#41;;
    triangleGainNode.connect&#40;audioContext.destination&#41;;

    triangle.start&#40;audioContext.currentTime&#41;;
    triangle.stop&#40;audioContext.currentTime + 1&#41;;
}
</code></pre><p>As shown above, we do that be quickly lowering the frequency of the triangle wave from 220Hz to 55Hz over the course of 100 milliseconds. The end result sounds like this:</p><p><audio controls="" src="https://ljpengelen.github.io/groovid19/kick/audio/pitch.mp3"></audio></p><p>If you want to achieve more of a 90s Euro house vibe, you can drop down from a higher frequency.</p><p><audio controls="" src="https://ljpengelen.github.io/groovid19/kick/audio/pitch-extreme.mp3"></audio></p><h2>White noise</h2><p>If you look at <a href='https://www.soundonsound.com/techniques/practical-bass-drum-synthesis'>how classic synthesizers emulate kick drums</a>, you’ll see that they’ll often use a little white noise to give the kicks a little more body. The Web Audio API doesn’t provide (white) noise out of the box, but you can use an audio buffer to <a href='https://noisehack.com/generate-noise-web-audio-api/'>create your own</a>.</p><pre><code class="lang-JavaScript">const generateWhiteNoiseBuffer = &#40;numberOfSamples&#41; =&gt; {
    const buffer = audioContext.createBuffer&#40;1, numberOfSamples, audioContext.sampleRate&#41;;

    const data = buffer.getChannelData&#40;0&#41;;
    for &#40;let i = 0; i &lt; numberOfSamples; ++i&#41; {
        data&#91;i&#93; = Math.random&#40;&#41; &#42; 2 - 1;
    }

    return buffer;
}

const whiteNoiseBuffer = generateWhiteNoiseBuffer&#40;audioContext.sampleRate&#41;;

const whiteNoiseBufferSource = &#40;&#41; =&gt; {
    const bufferSource = audioContext.createBufferSource&#40;&#41;;
    bufferSource.buffer = whiteNoiseBuffer;
    bufferSource.loop = true;
    bufferSource.loopEnd = audioContext.sampleRate
    return bufferSource;
}
</code></pre><p>Each buffer source returned by the function whiteNoiseBufferSource can only be started once. The same holds for the oscillator nodes that we’ve been creating above. The buffer returned by generateWhiteNoiseBuffer, however, can be reused. The result sounds like this:</p><p><audio controls="" src="https://ljpengelen.github.io/groovid19/kick/audio/white-noise.mp3"></audio></p><p>The next step is to apply a fade to this sound, just like we did before.</p><p><audio controls="" src="https://ljpengelen.github.io/groovid19/kick/audio/white-noise-release.mp3"></audio></p><p>After that, we cut of most of the higher frequencies using a low pass filter.</p><pre><code class="lang-JavaScript">const play = &#40;&#41; =&gt; {

    ...

    const noise = whiteNoiseBufferSource&#40;&#41;;

    const noiseGainNode = audioContext.createGain&#40;&#41;;
    noiseGainNode.gain.value = 1;
    noiseGainNode.gain.linearRampToValueAtTime&#40;0, audioContext.currentTime + 0.2&#41;;

    const noiseFilter = audioContext.createBiquadFilter&#40;&#41;;
    noiseFilter.type = 'lowpass';
    noiseFilter.frequency.value = 120;

    noise.connect&#40;noiseGainNode&#41;;
    noiseGainNode.connect&#40;noiseFilter&#41;;
    noiseFilter.connect&#40;audioContext.destination&#41;;

    noise.start&#40;audioContext.currentTime&#41;;
    noise.stop&#40;audioContext.currentTime + 1&#41;;
};
</code></pre><p>The end result sounds like this:</p><p><audio controls="" src="https://ljpengelen.github.io/groovid19/kick/audio/white-noise-low-pass.mp3"></audio></p><h2>End result</h2><p>Combining the sine-like wave and the filtered white noise leads to the following result:</p><p><audio controls="" src="https://ljpengelen.github.io/groovid19/kick/audio/triangle-and-noise.mp3"></audio></p><p>All you need is a handful of other instruments and you’re halfway making the next big dance hit, in your browser.</p><h2>Conclusion</h2><p>Let’s put the results of all this hard work into action. First, open Youtube, Spotify or whatever streaming service you like to play your favorite song. Then, visit <a href='https://ljpengelen.github.io/groovid19/kick-snare-hihat.html'>https://ljpengelen.github.io/groovid19/kick-snare-hihat.html</a> and press <code>q</code>, <code>w</code>, and <code>e</code> to drum along. Enjoy!</p>

<p>
  <i>Published: 2020-05-25</i>
  
</p>

<p>
  <i>
  Tagged:
  
  <span class="tag">
    <a href="tags/Browser-beats.html">Browser beats</a>
  </span>
  
  </i>
</p>


</div>
<div>
<h1>
  
  <a href="where-to-put-json-web-tokens.html">
  
  Where to put JSON Web Tokens in 2019
  
  </a>
  
</h1>
<p><em>This post first appeared on <a href='https://www.kabisa.nl/tech/'>Kabisa's Tech Blog</a>.</em></p><p>A few years ago, I gave a talk about JSON Web Tokens (JWTs) during a Meetup for Java enthusiasts in Eindhoven. Triggered by a talk about JWTs I attended recently, I decided to dust of my presentation and the demo applications I made back then to see whether they still hold up. It turns out that life is a little harder in 2019 than it was in 2016, at least as far as security and JWTs are concerned. Before we go into the details, we should first discuss the basics.</p><h2>JSON Web Tokens</h2><p>Essentially, a JSON Web Token is something that a server application would give to a client application, which the client would then use to authenticate itself with the server when doing requests. A JSON Web Token looks something like this:</p><p><strong class="word-break-break-all"> <span class="red">eyJhbGciOiJIUzUxMiJ9</span>.<span class="fuchsia">eyJleHAiOjE0NzYyOTAxNDksInN1YiI6IjEifQ</span>.<span class="blue">mvJEWu3kxm0WSUKu-qEVTBmuelM-2Te-VJHEFclVt_uR89ya0hNawkrgftQbAd-28lycLX2jXCgOGrA3XRg9Jg</span> </strong></p><p>If you look closely, you’ll see that it consists of three base64-encoded strings, joined by periods. If you decode the ones above, you end up with the following:</p><pre><code class="lang-json">{
  &quot;alg&quot;: &quot;HS512&quot;
}
</code></pre><pre><code class="lang-json">{
  &quot;exp&quot;: 1476290149,
  &quot;sub&quot;:&quot;1&quot;
}
</code></pre><pre><code class="lang-JavaScript">HMACSHA512&#40;
  base64UrlEncode&#40;header&#41; + &quot;.&quot; +
  base64UrlEncode&#40;payload&#41;,
  secret
&#41;
</code></pre><p>The first part is the header, the second is the payload, and the third is the signature. Anyone that gets their hands on this token can decode the strings. (Execute <code>atob&#40;&quot;eyJhbGciOiJIUzUxMiJ9&quot;&#41;</code> in the console of your browser if you want to see for yourself.) This means that anyone who gets their hands on the token can use the encoded information. Because only the server knows the secret that was used to compute the signature from the header and body, however, only the server can check the validity of a token by recomputing its expected signature and comparing it with the actual signature. Once the server has determined that a given JWT is valid, it knows that it issued the token itself, and that the data in the body can be trusted.</p><p>The header specifies which algorithm was used to compute the signature. In this case, that’s the HMAC-SHA512 algorithm.</p><p>The payload can contain any number of claims. In this example, the standard claims <code>exp</code> and <code>sub</code> are used. The claim <code>exp</code> (short for “expiration time”) specifies when the token expires. The claim <code>sub</code> (short for “subject”) specifies the subject of the token, usually something like a user of your app, denoted by an identifier. There are a number of other standard claims, and you’re free to add claims of your own.</p><h2>A trip down memory lane</h2><p>When I first read about JWTs, I was still used to working in an environment where deployments lead to downtime and were something that you’d do very early in the morning, so that they would impact as little end users as possible. Because they had to take place early in the morning, they didn’t occur very frequently. As a consequence, multiple features where collected and released together, and deployments automatically became stressful.</p><p>The back-end applications I worked on at that time maintained in-memory sessions for logged in users. If one of the servers went down, the users whose sessions were stored on that server would lose their session. In situations like that, you can’t just release a bug fix in the middle of the day, because you’d potentially log out part of your users.</p><p>First and foremost, I saw JWTs as a solution to this problem. (There are other, potentially better, solutions to this problem, but let’s ignore those for the time being.) Two or more instances of the same back-end application could sit behind a load balancer and issue JWTs to clients. All of these instances would be able to validate JWTs issued by any one of them. The body of each JWT could contain the information that would normally be stored in a session, such as the identifier of the currently logged-in user. If one of the instance would go down (during a deployment, for example), the load balancer would just route requests to the remaining instance(s) and clients wouldn’t notice anything.</p><p>I was convinced that JWTs could solve one of my problems, but I wasn’t sure how clients and servers should exchange them. Should they be sent along with requests in a header or should they be kept in a cookie? In the case of communication between back-end applications, the answer is clear. It’s much easier to follow conventions and put them in a header, and there’s no benefit to putting them in cookies instead. In the case of communication between client applications running in a browser and back-end applications, the answer is less clear. I remember frantically Googling for best practices while preparing for my presentation and being confronted with all sorts of contradictory claims and advice. Before we can discuss the conclusion I reached back then, we need to take a detour.</p><h2>CSRF and XSS</h2><p>The term cross-site request forgery (CSRF) is used for the situation where someone else’s web application secretly lets its visitors perform actions with your web application due to cookies still present from previous visits.</p><p>The following example (a modified version of one provided by <a href='https://owasp.org/www-community/attacks/csrf'>OWASP</a>) shows a form that tricks unsuspecting users into sending 10.000 euro (?) to my bank account at <a href="http://bank.com">http://bank.com</a>:</p><pre><code class="lang-html">&lt;form action=&quot;http://bank.com/transfer.do&quot; method=&quot;POST&quot;&gt;
  &lt;input type=&quot;hidden&quot; name=&quot;account&quot; value=&quot;LUC&quot;/&gt;
  &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;100000&quot;/&gt;
  &lt;input type=&quot;submit&quot; value=&quot;View my pictures&quot;/&gt;
&lt;/form&gt;
</code></pre><p>The term cross-site scripting (XSS) is used for the situation where someone is able to have their scripts executed as part of your web application.</p><p>The following example (directly stolen from <a href='https://www.owasp.org/index.php/Cross-site_Scripting_(XSS'>OWASP</a>) without any extra effort) shows part of a JSP template that allows anyone to execute code on the corresponding web page:</p><pre><code class="lang-java">&lt;% String eid = request.getParameter&#40;&quot;eid&quot;&#41;; %&gt;
	...
	Employee ID: &lt;%= eid %&gt;
</code></pre><p>Imagine the nightmares you’ll have after clicking <a href="http://example.com/employee.jsp?eid=alert%28%22you%20have%20been%20p0wned%22%29">http://example.com/employee.jsp?eid=alert%28%22you%20have%20been%20p0wned%22%29</a>...</p><h2>Cookie or header?</h2><p>If you put your JWTs in a cookie, you need to take precautions to combat CSRF. If you use secure, HTTP-only cookies, you don’t need to worry about XSS, however, because scripts don’t have access to the content of such cookies. There’s no way someone can abuse XSS and take your JWT to impersonate you.</p><p><i> Update 2023-01-06: Unfortunately, you </i>do<i> need to worry about XSS, even with secure, HTTP-only cookies. See the second addendum below to find out why. I'm leaving the rest of this post as it is because I don't want to rewrite history. However, I no longer agree with the conclusion at the end of this section and the final conclusion of this post. </i></p><p>If you put your JWTs in a header, you don’t need to worry about CSRF. You <em>do</em> need to worry about XSS, however. If someone can abuse XSS to steal your JWT, this person is able to impersonate you.</p><p>In my 2016 presentation, I stated that “defense against CSRF is straightforward and durable.” This statement was based on advice offered by the <a href='https://www.owasp.org/'>Open Web Application Security Project (OWASP)</a> at that time. Years later, defense against CSRF is still durable, but a little less straightforward. We’ll come back to that in a minute.</p><p>XSS, on the other hand, is something you need to constantly keep in mind. Each template you add could open up possibilities for XSS. The same holds for all those NPM packages you add to your front-end project, either directly or indirectly.</p><p>My conclusion from this is that JWTs belong in a secure, HTTP-only cookie, and should be used in combination with preventive measures against CSRF.</p><h2>Seeing is believing</h2><p>Because the proof of the pudding is in the eating, I wrote a simple front-end app and two back-end apps that demonstrate a session-based and JWT-based approach to authentication: <a href="https://github.com/ljpengelen/java-meetup-jwt">https://github.com/ljpengelen/java-meetup-jwt</a>.</p><p>With a simple <code>docker-compose</code> command, you can start three instances of either of the two back ends, a database, and an instance of nginx that serves the front end and acts as load balancer. You can open the front end in your browser, create an account, log in, and then stop some of the back-end instances with <code>docker stop</code>.</p><p>In the case of the JWT-based back end, it doesn’t matter which two instances you stop. In the case of the session-based back end, stopping the instance your connected to will terminate your session.</p><h2>Measures against CSRF</h2><p>The OWASP has a <a href='https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html'>cheat sheet about measures against CSRF</a>. The applications mentioned above use two of those measures.</p><p>First, they combat CSRF by checking the <code>Origin</code> and <code>Referer</code> headers. If the value of none of these headers match the expected value for a given request, the request is denied.</p><p>Second, each response returned by the back end contains a secure random token in two locations. One is sent in a header, where it can be read by the front end. The other is stored in the session (in case of the session-based back end) or in yet another secure, HTTP-only cookie (in case of the JWT-based back end) and is only accessible for the back end. These tokens are generated by a cryptographically secure random-number generator. The front-end application reads the token in the header of each response and passes it on with the next request. For each request to a protected endpoint, the back end checks whether the two tokens match. If they match, the request is granted. Otherwise, it’s denied.</p><p>Keeping track of the CSRF tokens in the front end is not completely straightforward. It takes a little effort to keep track of the latest token value and forward it with each request, but that’s an acceptable price to pay if you ask me.</p><p>For the JWT-based back end, both measures above come from the section of the <a href='https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html'>OWASP cheat sheet</a> describing measures for defense in depth. The second measure is known as the double-submit cookie technique. To mitigate the known issues of this technique, the CSRF token is stored in a JWT. Additionally, the account identifier is included in this JWT as well for logged-in users. Storing the CSRF token in a JWT makes it possible for the back-end application to verify that it produced the token itself. Combining the CSRF token with an account identifier makes it impossible for attackers to reuse a token for another user, even if they were able to <a href='https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie'>replace cookies</a>.</p><h2>Lifespan of a JWT</h2><p>Think about the following for a second: What happens to already issued JWTs when you change your credentials? What happens to already issued JWTs when you delete your account? In both scenarios, existing JWTs will remain valid. Without additional measures, JWTs remain valid until they expire or until the secret on the server is changed. If someone gets their hands on a token, it can be abused until it expires. If you want to invalidate a single token by changing the secret on the server, you invalidate all tokens.</p><p>When should a JWT expire? On one hand, they should expire as soon as possible, to prevent misuse for long periods. On the other hand, they should expire as late as possible, so that users don’t have to re-authenticate all the time.</p><p>In practice, two types of tokens are used together, to achieve the best of both worlds. A short-lived <em>access token</em> is used for authentication per request. A long-lived <em>refresh token</em> is used to generate new access token when needed.</p><p>Each time the refresh token is used to obtain a new access token, some additional checks could be made to enhance security. The refresh token can be used in combination with a blacklist, for example, to invalidate tokens that were issued for a particular user before a given point in time.</p><h2>What kind of abuse is this protecting you from?</h2><p>Because the JWTs are stored in secure, HTTP-only cookies, it is implausible that someone would be able to access the JWTs themselves. An attacker would, for example, need access to a victim’s computer to read the values of these cookies. The blacklist mentioned above could be used to invalidate JWTs comprised like this. However, if someone is able to access cookies directly from your computer, you have bigger problems to worry about that lie beyond the responsibility of an app developer. Moreover, there’s no reasonable defense against someone willing to turn your life into a Quentin Tarantino movie to access your data or credentials.</p><p>Other scenarios in which an attacker would be able to read the values of the JWTs would be when the attacker is able to intercept traffic between client and server or when an attacker would have access to the server. In such scenarios, all that can be done is patch up the security holes and change the secret key used to sign JWTs. The latter is the easiest way of invalidating all JWTs that have been issued before. Protection against these types of attacks cannot be implemented on the application level.</p><p>In short, your JWTs are reasonably safe from harm in their cookies. More realistically, however, it could happen that you inadvertently introduce an XSS vulnerability in your app. This could enable an attacker to access the value of the CSRF token, and use it in a CSRF attack. Also in this scenario, all you can do is change the secret to invalidate all tokens after patching the vulnerability.</p><h2>Conclusion</h2><p>I am not a security expert, and I must stress that you shouldn’t mistake my advice for the absolute truth on this subject. Instead, I hope this post allows you to follow my reasoning and helps you make informed decisions when you have to choose between different forms of authentication.</p><p>I’m well aware that the contradictory advice I encountered years ago is still out there, and that most people put their JWTs in a header. I guess those people are more scared of CSRF and that I’m more afraid of XSS.</p><p><i> Update 2023-01-06: As mentioned above, my opinion about where to put JWTs has changed. The second addendum below explains why. </i></p><h2>Addendum</h2><p>Right after this blog post got published, my colleague <a href='https://github.com/lukvdborne'>Luk van den Borne</a> shared a post about <a href='https://www.sjoerdlangkemper.nl/2017/02/09/cookie-prefixes/'>securing cookies with cookie prefixes</a>. Coincidentally, that post describes a way to patch one of the security holes in the JWT-based back end. This back end is vulnerable for an attack called <a href='https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#login-csrf'>login CSRF</a>, which is when an attacker is able to make users log in using the attacker’s account. This attack is possible when an attacker has access to an insecure subdomain of the domain that hosts your app. Attackers can use this insecure subdomain to set an arbitrary value for the cookie holding the CSRF token. This attack is only possible for the API call that is used to log in, because the CSRF token is tied to the user’s account identifier after logging in.</p><p>Simply adding the prefix <code>&#95;&#95;Host-</code> to the name of the cookie that holds the CSRF token triggers browser behavior that mitigates this type of attack, at least for users of Chrome and Firefox.</p><h2>Second addendum</h2><p>While copying the <a href='https://www.kabisa.nl/tech/where-to-put-json-web-tokens-in-2019/'>original version of this blog post</a> from Kabisa's Tech Blog on 2023-01-06, I noticed a comment by Dmytro Lapshyn that triggered me to reconsider the conclusion of this post. It turns out that the following statement made above is not completely true:</p><blockquote><p> "If you use secure, HTTP-only cookies, you don’t need to worry about XSS, however, because scripts don’t have access to the content of such cookies. There’s no way someone can abuse XSS and take your JWT to impersonate you." </p></blockquote><p>It's true that no one can use XSS to take your JWT from a secure, HTTP-only cookie and use it to impersonate you. Unfortunately, that doesn't mean that you don't have to worry about XSS.</p><p>Later on in the post above, the following statement is made:</p><blockquote><p> "More realistically, however, it could happen that you inadvertently introduce an XSS vulnerability in your app. This could enable an attacker to access the value of the CSRF token, and use it in a CSRF attack." </p></blockquote><p>At the time of writing, my reasoning was that someone else getting their hands on a JWT would be worse than someone getting their hands on an anti-CSRF token. A JWT can be used to impersonate the person for which it was issued. You can't do that with an anti-CSRF token by itself. However, if that anti-CSRF token is obtained via XSS or any other way of injecting and executing arbitrary JavaScript, then it's also possible to use JavaScript to perform HTTP requests that include both the anti-CRSF token and the cookie containing the JWT. Even without obtaining the JWT itself, the same kind of abuse is possible.</p><p>In conclusion, it's not worth going through all the extra trouble to pass JWTs along in cookies.</p><p>It's good to know that the more complicated approach has no benefits over the simpler approach. It's less reassuring that XSS or some other way of injecting and executing arbitrary JavaScript opens up the possibility of this kind of abuse. Keeping an eye on your own code is one thing. Keeping a close eye on your dependencies and their dependencies is another story.</p>

<p>
  <i>Published: 2019-08-26</i>
  
    -
    <i>Last updated: 2023-01-06</i>
  
</p>

<p>
  <i>
  Tagged:
  
  <span class="tag">
    <a href="tags/JSON-Web-Tokens.html">JSON Web Tokens</a>
  </span>
  
  </i>
</p>


</div>
    </div>
  </body>
</html>
